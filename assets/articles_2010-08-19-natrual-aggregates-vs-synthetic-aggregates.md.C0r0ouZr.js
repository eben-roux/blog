import{_ as e,c as t,o as a,k as n}from"./chunks/framework.B9tkazSO.js";const p=JSON.parse('{"title":"Natural Aggregates vs Synthetic Aggregates","description":"","frontmatter":{"title":"Natural Aggregates vs Synthetic Aggregates","date":"2010-08-19T00:00:00.000Z"},"headers":[],"relativePath":"articles/2010-08-19-natrual-aggregates-vs-synthetic-aggregates.md","filePath":"articles/2010-08-19-natrual-aggregates-vs-synthetic-aggregates.md"}'),r={name:"articles/2010-08-19-natrual-aggregates-vs-synthetic-aggregates.md"},o=n("<p>In databases we have natural keys such as company code, client number, and order number. Then we have synthetic keys that are typically globally unique identifiers (GUID) or auto-incrementing numbers (IDENTITY).</p><p>It seams to me that we may need to make this same natural and synthetic distinction when it comes to aggregates in domain-driven design (DDD). The whole Aggregate Root (AR) concept makes it extremely difficult to define certain structures; especially when starting out with DDD.</p><hr><p>I find the reason being that some entities don&#39;t work well as aggregate roots either:</p><ul><li>because the aggregate root seems to change depending on context; or</li><li>the entity is not a natural fit for an aggregate root.</li></ul><p>An example of a <strong>natural</strong> aggregate is something like <code>Order</code> and <code>OrderLine</code>. An order line can never exist without an order.</p><ul><li>Order has a Total that is calculated by summing the OrderLine Totals.</li><li>Total on order cannot mean anything other than the total of the order lines.</li></ul><p>An example of a <strong>synthetic</strong> aggregate is something like <code>GrapeBunch</code> containing a <code>GrapeStem</code> and a <code>GrapeBerry</code> collection.</p><ul><li>GrapeBunch can have a Weight that is calculated by summing the Weight of each GrapeBerry in the collection and adding the Weight of the GrapeStem.</li><li>The weight of the grape bunch cannot mean anything other than the sum of the grape berry weights and adding the weight of the grape stem.</li></ul><p>An example of a <strong>problematic</strong> aggregate by using an aggregate root is <code>GrapeStem</code> with a <code>GrapeBerry</code> collection.</p><ul><li>What does the <code>Weight</code> on GrapeStem mean?</li><li>We could have another method called <code>TotalWeight</code> but this is confusing.</li></ul>",11),i=[o];function s(g,c,l,h,d,u){return a(),t("div",null,i)}const y=e(r,[["render",s]]);export{p as __pageData,y as default};
