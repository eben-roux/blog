import{_ as o,c as t,o as n,a as e,l as a}from"./chunks/framework.B9tkazSO.js";const J=JSON.parse('{"title":"Many-to-Many Aggregate Roots","description":"","frontmatter":{"title":"Many-to-Many Aggregate Roots","date":"2009-09-09T00:00:00.000Z"},"headers":[],"relativePath":"articles/2009-09-09-many-to-many-aggregate-roots.md","filePath":"articles/2009-09-09-many-to-many-aggregate-roots.md"}'),s={name:"articles/2009-09-09-many-to-many-aggregate-roots.md"},r=e("p",null,[a("There has been some discussion around many-to-many relationships. Here is what Udi Dahan has to say: "),e("a",{href:"http://www.udidahan.com/2009/01/24/ddd-many-to-many-object-relational-mapping/"},"DDD & Many to Many Object Relational Mapping")],-1),i=e("hr",null,null,-1),d=e("p",null,"In his example Udi uses a Job and a JobBoard. As he states the typical modelling for this situation ends up with the Job having a collection of JobBoards and a JobBoard having a collection of Jobs. This is, as he states, somewhat problematic. He then reduces the relationship to a JobBoard having a collection of Jobs and a Job having no relation to JobBoards. This reduction of relationships is more-or-less what Eric Evans also states in his DDD book.",-1),l=e("p",null,"I would like to take another example: Order to Product. One order can contain many products and a Product can contain many orders. Yet we don't model it anywhere near an Order having a collection of products or a Product having a collection of orders.",-1),c=e("h3",{id:"relationships-represented-as-collections",tabindex:"-1"},[a("Relationships represented as collections "),e("a",{class:"header-anchor",href:"#relationships-represented-as-collections","aria-label":'Permalink to "Relationships represented as collections"'},"â€‹")],-1),h=e("p",null,"In this example it may seem obvious since we have all been modelling Order objects for a hundred years. Everyone should have the idea of an 'extended' association table since we have extra data that needs to be carried in the form of quantity and price. So we end up with the OrderItem. Funny that it is not called OrderProduct, yet the OrderItem refers to a product. That is because there is a natural boundary around an order. For some reason, these boudaries are not quite that apparent when working with something like a Job and a JobBoard.",-1),p=e("p",null,"Or am I totally off course here?",-1),m=[r,i,d,l,c,h,p];function u(g,y,_,b,f,w){return n(),t("div",null,m)}const x=o(s,[["render",u]]);export{J as __pageData,x as default};
