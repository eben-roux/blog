import{_ as e,c as t,o,k as a}from"./chunks/framework.B9tkazSO.js";const m=JSON.parse('{"title":"Aggregate Roots vs. Single Responsibility (and other issues)","description":"","frontmatter":{"title":"Aggregate Roots vs. Single Responsibility (and other issues)","date":"2010-07-27T00:00:00.000Z"},"headers":[],"relativePath":"articles/2010-07-27-aggregate-roots-vs-single-responsibility.md","filePath":"articles/2010-07-27-aggregate-roots-vs-single-responsibility.md"}'),n={name:"articles/2010-07-27-aggregate-roots-vs-single-responsibility.md"},s=a('<p>It is interesting to note how many questions there are around Aggregate Roots. Every-so-often someone will post a question on the Yahoo Domain-Driven Design Group regarding how to structure the Aggregate Roots. Now, I may be no genius but there are too many such questions for my liking. It indicates that something is hard to understand; and when something is hard to understand it probably highlighting a larger problem.</p><p><em><strong>2024-05-11</strong></em>: Yahoo groups no longer exist.</p><hr><h3 id="aggregate-vs-aggregate-root" tabindex="-1">Aggregate vs. Aggregate Root <a class="header-anchor" href="#aggregate-vs-aggregate-root" aria-label="Permalink to &quot;Aggregate vs. Aggregate Root&quot;">​</a></h3><blockquote><p>&quot;Cluster ENTITIES and VALUE OBJECTS into AGGREGATES and define boundaries around each. Choose one ENTITY to be the root of the AGGREGATE, and control all access to the objects inside the boundary through the root.&quot; (Evans, p. 129)</p></blockquote><p>In one of Eric&#39;s presentations he touches on this; stating the difference between an Aggregate and an Aggregate Root. I have mentioned Eric&#39;s bunch of grapes example in a <a href="./2009-11-23-ddd-not-equal-to-ar.html">previous post</a> so I will not re-hash it here.</p><p>The gang of four has two principles of object-oriented design:</p><ul><li>&quot;Program to an interface, not an implementation.&quot; (Gamma <em>et. al.</em> p. 18)</li><li>&quot;Favor object composition over class inheritance.&quot; (Gamma <em>et. al.</em> p. 20)</li></ul><p>So what&#39;s the point? At first glance it seems that we are working with composition for both the Aggregate and the Aggregate Root. On page 128 of Eric&#39;s blue book there is a class diagram modelling a car. The car class is adorned with two stereotypes: <code>&lt;&lt;Entity&gt;&gt;</code> and <code>&lt;&lt;Aggregate Root&gt;&gt;</code>.</p><h4 id="single-responsibility" tabindex="-1">Single Responsibility? <a class="header-anchor" href="#single-responsibility" aria-label="Permalink to &quot;Single Responsibility?&quot;">​</a></h4><p>So is an Aggregate Root called Car sticking to the Single Responsibility Principle? It <em>is</em> responsible for Car behaviour; but also for the consistency within the Aggregate since it now represents an Aggregate with the Car entity as the Root. It seems as though the Car is doing more than it should and I think that this leads to many issues.</p><p>Could it be that the Car Aggregate Root concept is a specialisation of the Car entity? So, following this reasoning it is actually inheritance. The reason we do not see it is because it is flattened into the Car entity and, therefore, the car no longer adheres to SRP. My reasoning could be flawed so I am open to persuasion.</p><h3 id="does-the-aggregate-root-change-depending-on-the-use-case" tabindex="-1">Does the Aggregate Root change depending on the use case? <a class="header-anchor" href="#does-the-aggregate-root-change-depending-on-the-use-case" aria-label="Permalink to &quot;Does the Aggregate Root change depending on the use case?&quot;">​</a></h3><p>The problem the <code>Aggregate Root</code> concept is trying to solve is <em>consistency</em>. It groups objects together to ensure that they are used as a unit. When one looks at the philosophy behind <a href="http://www.artima.com/articles/dci_vision.html" target="_blank" rel="noreferrer">Data-Context-Interaction (DCI)</a> it appears as though the context is pushed into the root entity. When a different context (use-case) enters the fray that also makes use of the same <code>Aggregate Root</code> it appears as though the <code>Aggregate Root</code> is changing.</p><p>There <em>has</em> been some discussion around the issue of the <code>Aggregate Root</code> <em>changing</em> depending on the use case, i.e. a different entity is regarded as the root depending on the use case. Now some folks state that the <code>Aggregate Root</code> isn&#39;t really changing but the fact that it <em>appears</em> to be changing should be an indication that you are working with different <strong>Bounded Context</strong>. Now this is probably true; especially since the word <strong>context</strong> make an appearance.</p><h4 id="a-quick-note-on-bounded-contexts" tabindex="-1">A quick note on Bounded Contexts <a class="header-anchor" href="#a-quick-note-on-bounded-contexts" aria-label="Permalink to &quot;A quick note on Bounded Contexts&quot;">​</a></h4><p>Let&#39;s stay with the Car example. Let&#39;s say we have a car rental company and we have our own workshop. Now our car could do something along the lines of <code>Car.ScheduleMaintenance(_dependencies)</code> and <code>Car.MakeBooking(_dependencies)</code>.</p><p>This is where issues start creeping into the design. The maintenance management folks don&#39;t give two hoots about rentals and, likewise, the rental folks are not too interested in maintenance; they only want to know whether the car is available for rental. Enter the Bounded Context (<strong>BC</strong>). We have a <strong>Maintenance Management BC</strong> and <strong>Rental Administration BC</strong>. Of course we would probably also need a <strong>Fleet Management BC</strong> with e.g <code>Car.Commission()</code> and <code>Car.Decommission()</code>.</p><p>The particular Car is the same car in the real world. Just look at the registration number. However, the context within which it is used changes. It is, in OO terms, a specialization of a Car class to incorporate the context. This inevitably leads to data duplication of sorts since the data for each BC will probably be stored in different databases.</p><p>Assuming we view this as a problem, how could we solve this? As proposed by the GoF we could try composition. In DCI terms the context can aggregate the different entities. I previously blogged about an <a href="./2009-11-23-ddd-not-equal-to-ar.html#aneamic-use-case-model">aneamic use-case model</a> and the context looks an awful lot like a use-case. I have not played around with how to get these concepts into code but we&#39;ll get there.</p><h3 id="repositories-return-aggregate-roots" tabindex="-1">Repositories return Aggregate Roots? <a class="header-anchor" href="#repositories-return-aggregate-roots" aria-label="Permalink to &quot;Repositories return Aggregate Roots?&quot;">​</a></h3><p>Now this one is rather weird. I have no idea where this comes from. For those that have the Domain-Driven Design book by Eric Evans it is a simple case of opening the front cover and having a look at the diagram printed on the inside where it clearly shows two arrows that point to <strong>Repositories</strong>. One comes from <strong>Entities</strong> and the other from <strong>Aggregates</strong> (note: not Aggregate Root), like so:</p><ul><li>[Entities] --- <em>access</em> with --&gt; [Repositories]</li><li>[Aggregates] --- <em>access</em> with --&gt; [Repositories]</li></ul><p>The fact is that a repository <strong>always</strong> returns an entity whether or not that entity is an aggregate. So if folks want to call it an AR when there is no aggregation it probably will not restrict the design.</p>',24),i=[s];function r(g,h,l,c,d,p){return o(),t("div",null,i)}const b=e(n,[["render",r]]);export{m as __pageData,b as default};
