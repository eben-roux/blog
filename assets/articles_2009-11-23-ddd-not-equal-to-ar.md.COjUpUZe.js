import{_ as e,c as t,o as a,k as o}from"./chunks/framework.B9tkazSO.js";const g=JSON.parse('{"title":"DDD != AR","description":"","frontmatter":{"title":"DDD != AR","date":"2009-11-23T00:00:00.000Z"},"headers":[],"relativePath":"articles/2009-11-23-ddd-not-equal-to-ar.md","filePath":"articles/2009-11-23-ddd-not-equal-to-ar.md"}'),n={name:"articles/2009-11-23-ddd-not-equal-to-ar.md"},s=o('<p>I have been struggling with many aspects of object-oriented development over last couple of years, all in an effort to improve my software. I have, along with others, been trapped in the DDD Aggregate Root thinking that appears to be everywhere. It appears as though there is this opinion that ARs are the centre of the universe and I have come to the conclusion that it must have something to do with the <strong>consistency boundary</strong> afforded by an AR. This seems to have become the central theme. Almost as though it became necessary to <em>define</em> DDD in some structural sense.</p><hr><p>The idea that an the AR changes from use-case to use-case is not true. The consistency boundary may, however, change. What contributed to my thinking seems to be the fact that everyone thinks that the only object that may be loaded by a Repository is an AR. This too is a fallacy.</p><p><em>Any</em> entity may be loaded from a Repository. However, the entity, even if it does not contain any value objects, could be regarded as an aggregate root for all practical purposes.</p><h3 id="so-what-is-an-aggregate-root" tabindex="-1">So what is an Aggregate Root? <a class="header-anchor" href="#so-what-is-an-aggregate-root" aria-label="Permalink to &quot;So what is an Aggregate Root?&quot;">​</a></h3><p>The aggregate concept is not new. The classic <code>Order</code> / <code>OrderLine</code> example comes to mind. An OrderLine has no reason to exist without it&#39;s Order. However, ownership could be confused with aggregation. I know I have. One may manipulate an Order directly, even though it belongs to a <code>Customer</code>. One would never manipulate an <code>OrderLine</code> directly. So an AR boils down to how you manipulate your objects. The consistency is a side effect since an AR only makes sense as a whole in the same way a class only makes sense as a whole. Both should remain consistent.</p><p>So to manipulate an aggregate we nominate an entity within the aggregate to represent the aggregate. This becomes the <em>Aggregate Root</em>.</p><p>But in many, if not most, cases this entity is only the representative. Using Eric Evans&#39; example in his &#39;What I learned...&#39; presentation: an aggregate consisting of a Stem and a collection of <code>Grape</code> objects may have, as the root, the <code>Stem</code> class. But this does not <em>really</em> represent the <code>GrapeBunch</code> aggregate properly. In some instances one may probably want a <code>GrapeBunch</code> class and use composition to get to the aggregate. Mr. Evans mentions that he has no real issue with doing this. However, I feel too many aggregates end up as abstract concepts in the domain. It may be that the defined Ubiquitous Language has missed the concept or that the domain experts even missed the aggregation themselves.</p><h3 id="aneamic-use-case-model" tabindex="-1">Aneamic Use-Case Model <a class="header-anchor" href="#aneamic-use-case-model" aria-label="Permalink to &quot;Aneamic Use-Case Model&quot;">​</a></h3><p>It is my opinion that use-cases (or user stories, or whatever you want to call them) may not receive the necessary attention in our modelling. Well, mine anyway. I have been using a <strong>&#39;Tasks&#39;</strong> layer but have been trying to move these into my entities and ARs. This may have been a mistake.</p><p>I will be mentioning bits from <a href="http://en.wikipedia.org/wiki/Use_case" target="_blank" rel="noreferrer">the use case</a> and <a href="http://en.wikipedia.org/wiki/Sequence_diagram" target="_blank" rel="noreferrer">sequence diagram</a> Wikipedia articles.</p><p>Firstly, we need to see where a use-case fits in. There are essentially two kinds of &#39;workflows&#39; in any system: sequential and a state-machine.</p><p>Now looking at what a sequence diagram does:</p><blockquote><p>A sequence diagram shows, as parallel vertical lines (&quot;lifelines&quot;), different processes or objects that live simultaneously, and, as horizontal arrows, the messages exchanged between them, in the order in which they occur. This allows the specification of simple runtime scenarios in a graphical manner.</p></blockquote><p>And what a use-case is:</p><ul><li>Each use case focuses on describing how to achieve a goal or task.</li><li>Use cases should not be confused with the features of the system under consideration.</li><li>A use case defines the interactions between external actors and the system under consideration to accomplish a goal.</li></ul><p>A use-case appears to fit the idea of a sequential workflow. It is completed in one step. So we can call it an <em>operation</em>. This <em>operation</em> takes place in response to a command from an actor in the system. If may then publish an event. These operations resemble <em>transaction script</em> [PoEAA] and may be why some folks choose to stay away from them since it is often confused with an <em>anaemic domain model</em>. However, they are, in sooth, <em>operation script</em> (also Fowler). Now, I have been defining a &#39;Task&#39; for my operations but since moving to DDD-thinking I have been trying to move these into my domain classes. It isn&#39;t working. I feel that use-cases need to be made explicit also. They lie in-between task-based domain interaction and state-machines. The other thing is that one operation may need to interact with another.</p><h3 id="state-machines" tabindex="-1">State Machines <a class="header-anchor" href="#state-machines" aria-label="Permalink to &quot;State Machines&quot;">​</a></h3><p>The term <em>workflow</em> is most often associated with a state machine. The <a href="http://en.wikipedia.org/wiki/State_machine" target="_blank" rel="noreferrer">finite state machine</a> article on Wikipedia may be referenced for more information.</p><p>Workflow does not fit into the typical use-case definition and it is probably the reason why the term <em>process</em> is used quite often in business requirements documentation.</p><h3 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-label="Permalink to &quot;Conclusion&quot;">​</a></h3><p>What I find interesting is that in any business domain of reasonable complexity one will find all these concepts hidden away. Developing a computer-based solution that takes all of these factors into consideration is a monumental effort and in many cases is under-estimated. What I have seen over the years appears to be a tendency to focus on specific technologies to <em>try</em> and overcome this intricate mass. Software such as BizTalk has been abused.</p><p>At the root of everything, though, is data. We need data to represent the real world state. This leads to a group of developers relying only on data manipulation to perform <em>all</em> these specialized areas. But everything is built up from the data, so (bold is good):</p><ul><li><strong>Data Structures</strong><ul><li>Data Manipulation (Procedural Code / Transaction Script)</li><li><strong>Behaviour (OO Code)</strong><ul><li>Entity-Based Interaction</li><li><strong>Task-Based Interaction</strong><ul><li><strong>Use-Case Modeling (Operation Script)</strong><ul><li><strong>State Machines (Workflow / Saga)</strong></li></ul></li></ul></li></ul></li></ul></li></ul><p>And to top it all off we will add Service-Orientation. SOA would wrap all of these.</p>',25),i=[s];function r(h,l,c,d,m,p){return a(),t("div",null,i)}const f=e(n,[["render",r]]);export{g as __pageData,f as default};
